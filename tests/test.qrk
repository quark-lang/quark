(import "std:prelude.qrk")
(import "std:classes/monad.qrk")

(defn const [a b] a)

(instance [] (Functor (Tuple a)) [
  (defn fmap [f x] (match x
    [(Tuple a b) (Tuple a (f b))]))
])

(let print! (. print show))

(let <$> fmap)

(defn sumPair [xs ys] 
  (>>= xs (fn [x] (>>= ys (fn [y] (return (+ x y)))))))

(class (Typeable a) [
  (declare type (-> a str))
])

(instance [] (Typeable int) [
  (let type (const "int"))
])

(instance [] (Typeable char) [
  (let type (const "char"))
])

(instance [(Typeable a)] (Typeable (List a)) [
  (defn type [x]
    (match x
      [Nil "List"]
      [(Cons y _) (++ "List<" (++ (type y) ">"))]))
])

(instance [(Typeable a) (Typeable b)] (Typeable (Tuple a b)) [
  (defn type [x]
    (match x
      [(Tuple a b) (++ "(" (++ (type a) (++ ", " (++ (type b) ")"))))]))
])

(instance [] (Show Void) [
  (let show (const "()"))
])

(instance [] (Show bool) [
  (defn show [x] (blue (match x
    [true "true"]
    [false "false"])))
])

(defn map [f xs] (>>= xs f))

(let test (fn [x] (>>= x (fn [y] (return y)))))

(let main (fn [] {
  (print! (test (Tuple [1 2 3] ["a" "b" "c"])))
}))